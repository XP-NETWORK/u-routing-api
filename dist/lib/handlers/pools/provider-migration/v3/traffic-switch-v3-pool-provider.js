import { log, metric, MetricLoggerUnit } from '@uniswap/smart-order-router';
import { POOL_PROVIDER_TRAFFIC_SWITCH_CONFIGURATION } from '../../util/pool-provider-traffic-switch-configuration';
import JSBI from 'jsbi';
export class TrafficSwitchV3PoolProvider {
    constructor({ currentPoolProvider, targetPoolProvider, sourceOfTruthPoolProvider }) {
        this.SHOULD_SWITCH_TRAFFIC = () => POOL_PROVIDER_TRAFFIC_SWITCH_CONFIGURATION.switchPercentage > this.getRandomPercentage();
        this.SHOULD_SAMPLE_TRAFFIC = () => POOL_PROVIDER_TRAFFIC_SWITCH_CONFIGURATION.samplingPercentage > this.getRandomPercentage();
        this.currentPoolProvider = currentPoolProvider;
        this.targetPoolProvider = targetPoolProvider;
        this.sourceOfTruthPoolProvider = sourceOfTruthPoolProvider;
    }
    getPoolAddress(tokenA, tokenB, feeAmount) {
        // The underlying logic for getting the pool address is always from the
        // source of truth pool provider, and the result is deterministic.
        // It doesn't matter which pool provider we use, so we can start with the target
        // pool provider, which will delegate to the source of truth pool provider.
        return this.targetPoolProvider.getPoolAddress(tokenA, tokenB, feeAmount);
    }
    async getPools(tokenPairs, providerConfig) {
        const sampleTraffic = this.SHOULD_SAMPLE_TRAFFIC();
        const switchTraffic = this.SHOULD_SWITCH_TRAFFIC();
        let currentProviderPools;
        let targetProviderPools;
        metric.putMetric('V3_POOL_PROVIDER_POOL_TRAFFIC_TOTAL', 1, MetricLoggerUnit.None);
        if (sampleTraffic) {
            metric.putMetric('V3_POOL_PROVIDER_POOL_TRAFFIC_SAMPLING', 1, MetricLoggerUnit.None);
            currentProviderPools = await this.currentPoolProvider.getPools(tokenPairs, providerConfig);
            targetProviderPools = await this.targetPoolProvider.getPools(tokenPairs, providerConfig);
            // If we need to sample the traffic, we don't want to make it a blocking I/O
            this.sampleTraffic(tokenPairs, currentProviderPools, targetProviderPools, providerConfig);
        }
        if (switchTraffic) {
            metric.putMetric('V3_POOL_PROVIDER_POOL_TRAFFIC_TARGET', 1, MetricLoggerUnit.None);
            return targetProviderPools !== null && targetProviderPools !== void 0 ? targetProviderPools : (await this.targetPoolProvider.getPools(tokenPairs, providerConfig));
        }
        else {
            metric.putMetric('V3_POOL_PROVIDER_POOL_TRAFFIC_CURRENT', 1, MetricLoggerUnit.None);
            return currentProviderPools !== null && currentProviderPools !== void 0 ? currentProviderPools : (await this.currentPoolProvider.getPools(tokenPairs, providerConfig));
        }
    }
    async sampleTraffic(tokenPairs, currentProviderPools, targetProviderPools, providerConfig) {
        const truthProviderPools = await this.sourceOfTruthPoolProvider.getPools(tokenPairs, providerConfig);
        truthProviderPools.getAllPools().forEach((pool) => {
            const currentProviderPool = currentProviderPools.getPool(pool.token0, pool.token1, pool.fee);
            if (!currentProviderPool) {
                // We don't expect missing pool, but export metric in case we see any
                metric.putMetric('V3_POOL_PROVIDER_POOL_CURRENT_MISSING', 1, MetricLoggerUnit.None);
                log.info(`v3 Pool ${pool.token0.symbol} ${pool.token1.symbol} ${pool.fee} not found in the current pool provider.`);
            }
            else {
                const sameQuote = JSBI.equal(currentProviderPool.sqrtRatioX96, pool.sqrtRatioX96);
                const sameLiquidity = JSBI.equal(currentProviderPool.liquidity, pool.liquidity);
                const accurate = sameQuote && sameLiquidity;
                if (!sameQuote) {
                    log.info(`v3 Pool ${pool.token0.symbol} ${pool.token1.symbol} ${pool.fee} quote mismatch: 
            current ${currentProviderPool.sqrtRatioX96} vs truth ${pool.sqrtRatioX96}.`);
                    metric.putMetric('V3_POOL_PROVIDER_POOL_CURRENT_QUOTE_MISMATCH', 1, MetricLoggerUnit.None);
                }
                if (!sameLiquidity) {
                    log.info(`v3 Pool ${pool.token0.symbol} ${pool.token1.symbol} ${pool.fee} liquidity mismatch: 
            current ${currentProviderPool.liquidity} vs truth ${pool.liquidity}.`);
                    metric.putMetric('V3_POOL_PROVIDER_POOL_CURRENT_LIQUIDITY_MISMATCH', 1, MetricLoggerUnit.None);
                }
                if (!accurate) {
                    metric.putMetric('V3_POOL_PROVIDER_POOL_CURRENT_ACCURACY_MISMATCH', 1, MetricLoggerUnit.None);
                }
                else {
                    metric.putMetric('V3_POOL_PROVIDER_POOL_CURRENT_ACCURACY_MATCH', 1, MetricLoggerUnit.None);
                }
            }
            const targetProviderPool = targetProviderPools.getPool(pool.token0, pool.token1, pool.fee);
            if (!targetProviderPool) {
                // We don't expect missing pool, but export metric in case we see any
                metric.putMetric('V3_POOL_PROVIDER_POOL_TARGET_MISSING', 1, MetricLoggerUnit.None);
                log.info(`v3 Pool ${pool.token0.symbol} ${pool.token1.symbol} ${pool.fee} not found in the target pool provider.`);
            }
            else {
                const sameQuote = JSBI.equal(targetProviderPool.sqrtRatioX96, pool.sqrtRatioX96);
                const sameLiquidity = JSBI.equal(targetProviderPool.liquidity, pool.liquidity);
                const accurate = sameQuote && sameLiquidity;
                if (!sameQuote) {
                    log.info(`v3 Pool ${pool.token0.symbol} ${pool.token1.symbol} ${pool.fee} quote mismatch: 
            target ${targetProviderPool.sqrtRatioX96} vs truth ${pool.sqrtRatioX96}.`);
                    metric.putMetric('V3_POOL_PROVIDER_POOL_TARGET_QUOTE_MISMATCH', 1, MetricLoggerUnit.None);
                }
                if (!sameLiquidity) {
                    log.info(`v3 Pool ${pool.token0.symbol} ${pool.token1.symbol} ${pool.fee} liquidity mismatch: 
            target ${targetProviderPool.liquidity} vs truth ${pool.liquidity}.`);
                    metric.putMetric('V3_POOL_PROVIDER_POOL_TARGET_LIQUIDITY_MISMATCH', 1, MetricLoggerUnit.None);
                }
                if (!accurate) {
                    metric.putMetric('V3_POOL_PROVIDER_POOL_TARGET_ACCURACY_MISMATCH', 1, MetricLoggerUnit.None);
                }
                else {
                    metric.putMetric('V3_POOL_PROVIDER_POOL_TARGET_ACCURACY_MATCH', 1, MetricLoggerUnit.None);
                }
            }
        });
    }
    getRandomPercentage() {
        return Math.floor(Math.random() * 100);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhZmZpYy1zd2l0Y2gtdjMtcG9vbC1wcm92aWRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL2xpYi9oYW5kbGVycy9wb29scy9wcm92aWRlci1taWdyYXRpb24vdjMvdHJhZmZpYy1zd2l0Y2gtdjMtcG9vbC1wcm92aWRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQW1CLEdBQUcsRUFBRSxNQUFNLEVBQUUsZ0JBQWdCLEVBQWtCLE1BQU0sNkJBQTZCLENBQUE7QUFJNUcsT0FBTyxFQUFFLDBDQUEwQyxFQUFFLE1BQU0sdURBQXVELENBQUE7QUFDbEgsT0FBTyxJQUFJLE1BQU0sTUFBTSxDQUFBO0FBUXZCLE1BQU0sT0FBTywyQkFBMkI7SUFVdEMsWUFBWSxFQUFFLG1CQUFtQixFQUFFLGtCQUFrQixFQUFFLHlCQUF5QixFQUFrQztRQUwvRiwwQkFBcUIsR0FBRyxHQUFHLEVBQUUsQ0FDOUMsMENBQTBDLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLG1CQUFtQixFQUFFLENBQUE7UUFDdkUsMEJBQXFCLEdBQUcsR0FBRyxFQUFFLENBQzlDLDBDQUEwQyxDQUFDLGtCQUFrQixHQUFHLElBQUksQ0FBQyxtQkFBbUIsRUFBRSxDQUFBO1FBRzFGLElBQUksQ0FBQyxtQkFBbUIsR0FBRyxtQkFBbUIsQ0FBQTtRQUM5QyxJQUFJLENBQUMsa0JBQWtCLEdBQUcsa0JBQWtCLENBQUE7UUFDNUMsSUFBSSxDQUFDLHlCQUF5QixHQUFHLHlCQUF5QixDQUFBO0lBQzVELENBQUM7SUFFRCxjQUFjLENBQ1osTUFBYSxFQUNiLE1BQWEsRUFDYixTQUFvQjtRQU1wQix1RUFBdUU7UUFDdkUsa0VBQWtFO1FBQ2xFLGdGQUFnRjtRQUNoRiwyRUFBMkU7UUFDM0UsT0FBTyxJQUFJLENBQUMsa0JBQWtCLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUUsU0FBUyxDQUFDLENBQUE7SUFDMUUs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LGtCQUFrQixDQUFDLFNBQVMsYUFBYSxJQUFJLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQTtvQkFFdEUsTUFBTSxDQUFDLFNBQVMsQ0FBQyxpREFBaUQsRUFBRSxDQUFDLEVBQUUsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUE7aUJBQzlGO2dCQUVELElBQUksQ0FBQyxRQUFRLEVBQUU7b0JBQ2IsTUFBTSxDQUFDLFNBQVMsQ0FBQyxnREFBZ0QsRUFBRSxDQUFDLEVBQUUsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUE7aUJBQzdGO3FCQUFNO29CQUNMLE1BQU0sQ0FBQyxTQUFTLENBQUMsNkNBQTZDLEVBQUUsQ0FBQyxFQUFFLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFBO2lCQUMxRjthQUNGO1FBQ0gsQ0FBQyxDQUFDLENBQUE7SUFDSixDQUFDO0lBRU8sbUJBQW1CO1FBQ3pCLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsR0FBRyxDQUFDLENBQUE7SUFDeEMsQ0FBQztDQUNGIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSVYzUG9vbFByb3ZpZGVyLCBsb2csIG1ldHJpYywgTWV0cmljTG9nZ2VyVW5pdCwgVjNQb29sQWNjZXNzb3IgfSBmcm9tICdAdW5pc3dhcC9zbWFydC1vcmRlci1yb3V0ZXInXG5pbXBvcnQgeyBUb2tlbiB9IGZyb20gJ0B1bmlzd2FwL3Nkay1jb3JlJ1xuaW1wb3J0IHsgRmVlQW1vdW50LCBQb29sIH0gZnJvbSAnQHVuaXN3YXAvdjMtc2RrJ1xuaW1wb3J0IHsgUHJvdmlkZXJDb25maWcgfSBmcm9tICdAdW5pc3dhcC9zbWFydC1vcmRlci1yb3V0ZXIvYnVpbGQvbWFpbi9wcm92aWRlcnMvcHJvdmlkZXInXG5pbXBvcnQgeyBQT09MX1BST1ZJREVSX1RSQUZGSUNfU1dJVENIX0NPTkZJR1VSQVRJT04gfSBmcm9tICcuLi8uLi91dGlsL3Bvb2wtcHJvdmlkZXItdHJhZmZpYy1zd2l0Y2gtY29uZmlndXJhdGlvbidcbmltcG9ydCBKU0JJIGZyb20gJ2pzYmknXG5cbmV4cG9ydCB0eXBlIFRyYWZmaWNTd2l0Y2hQb29sUHJvdmlkZXJQcm9wcyA9IHtcbiAgY3VycmVudFBvb2xQcm92aWRlcjogSVYzUG9vbFByb3ZpZGVyXG4gIHRhcmdldFBvb2xQcm92aWRlcjogSVYzUG9vbFByb3ZpZGVyXG4gIHNvdXJjZU9mVHJ1dGhQb29sUHJvdmlkZXI6IElWM1Bvb2xQcm92aWRlclxufVxuXG5leHBvcnQgY2xhc3MgVHJhZmZpY1N3aXRjaFYzUG9vbFByb3ZpZGVyIGltcGxlbWVudHMgSVYzUG9vbFByb3ZpZGVyIHtcbiAgcHJpdmF0ZSByZWFkb25seSBjdXJyZW50UG9vbFByb3ZpZGVyOiBJVjNQb29sUHJvdmlkZXJcbiAgcHJpdmF0ZSByZWFkb25seSB0YXJnZXRQb29sUHJvdmlkZXI6IElWM1Bvb2xQcm92aWRlclxuICBwcml2YXRlIHJlYWRvbmx5IHNvdXJjZU9mVHJ1dGhQb29sUHJvdmlkZXI6IElWM1Bvb2xQcm92aWRlclxuXG4gIHByb3RlY3RlZCByZWFkb25seSBTSE9VTERfU1dJVENIX1RSQUZGSUMgPSAoKSA9PlxuICAgIFBPT0xfUFJPVklERVJfVFJBRkZJQ19TV0lUQ0hfQ09ORklHVVJBVElPTi5zd2l0Y2hQZXJjZW50YWdlID4gdGhpcy5nZXRSYW5kb21QZXJjZW50YWdlKClcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IFNIT1VMRF9TQU1QTEVfVFJBRkZJQyA9ICgpID0+XG4gICAgUE9PTF9QUk9WSURFUl9UUkFGRklDX1NXSVRDSF9DT05GSUdVUkFUSU9OLnNhbXBsaW5nUGVyY2VudGFnZSA+IHRoaXMuZ2V0UmFuZG9tUGVyY2VudGFnZSgpXG5cbiAgY29uc3RydWN0b3IoeyBjdXJyZW50UG9vbFByb3ZpZGVyLCB0YXJnZXRQb29sUHJvdmlkZXIsIHNvdXJjZU9mVHJ1dGhQb29sUHJvdmlkZXIgfTogVHJhZmZpY1N3aXRjaFBvb2xQcm92aWRlclByb3BzKSB7XG4gICAgdGhpcy5jdXJyZW50UG9vbFByb3ZpZGVyID0gY3VycmVudFBvb2xQcm92aWRlclxuICAgIHRoaXMudGFyZ2V0UG9vbFByb3ZpZGVyID0gdGFyZ2V0UG9vbFByb3ZpZGVyXG4gICAgdGhpcy5zb3VyY2VPZlRydXRoUG9vbFByb3ZpZGVyID0gc291cmNlT2ZUcnV0aFBvb2xQcm92aWRlclxuICB9XG5cbiAgZ2V0UG9vbEFkZHJlc3MoXG4gICAgdG9rZW5BOiBUb2tlbixcbiAgICB0b2tlbkI6IFRva2VuLFxuICAgIGZlZUFtb3VudDogRmVlQW1vdW50XG4gICk6IHtcbiAgICBwb29sQWRkcmVzczogc3RyaW5nXG4gICAgdG9rZW4wOiBUb2tlblxuICAgIHRva2VuMTogVG9rZW5cbiAgfSB7XG4gICAgLy8gVGhlIHVuZGVybHlpbmcgbG9naWMgZm9yIGdldHRpbmcgdGhlIHBvb2wgYWRkcmVzcyBpcyBhbHdheXMgZnJvbSB0aGVcbiAgICAvLyBzb3VyY2Ugb2YgdHJ1dGggcG9vbCBwcm92aWRlciwgYW5kIHRoZSByZXN1bHQgaXMgZGV0ZXJtaW5pc3RpYy5cbiAgICAvLyBJdCBkb2Vzbid0IG1hdHRlciB3aGljaCBwb29sIHByb3ZpZGVyIHdlIHVzZSwgc28gd2UgY2FuIHN0YXJ0IHdpdGggdGhlIHRhcmdldFxuICAgIC8vIHBvb2wgcHJvdmlkZXIsIHdoaWNoIHdpbGwgZGVsZWdhdGUgdG8gdGhlIHNvdXJjZSBvZiB0cnV0aCBwb29sIHByb3ZpZGVyLlxuICAgIHJldHVybiB0aGlzLnRhcmdldFBvb2xQcm92aWRlci5nZXRQb29sQWRkcmVzcyh0b2tlbkEsIHRva2VuQiwgZmVlQW1vdW50KVxuICB9XG5cbiAgYXN5bmMgZ2V0UG9vbHModG9rZW5QYWlyczogW1Rva2VuLCBUb2tlbiwgRmVlQW1vdW50XVtdLCBwcm92aWRlckNvbmZpZz86IFByb3ZpZGVyQ29uZmlnKTogUHJvbWlzZTxWM1Bvb2xBY2Nlc3Nvcj4ge1xuICAgIGNvbnN0IHNhbXBsZVRyYWZmaWMgPSB0aGlzLlNIT1VMRF9TQU1QTEVfVFJBRkZJQygpXG4gICAgY29uc3Qgc3dpdGNoVHJhZmZpYyA9IHRoaXMuU0hPVUxEX1NXSVRDSF9UUkFGRklDKClcbiAgICBsZXQgY3VycmVudFByb3ZpZGVyUG9vbHNcbiAgICBsZXQgdGFyZ2V0UHJvdmlkZXJQb29sc1xuXG4gICAgbWV0cmljLnB1dE1ldHJpYygnVjNfUE9PTF9QUk9WSURFUl9QT09MX1RSQUZGSUNfVE9UQUwnLCAxLCBNZXRyaWNMb2dnZXJVbml0Lk5vbmUpXG5cbiAgICBpZiAoc2FtcGxlVHJhZmZpYykge1xuICAgICAgbWV0cmljLnB1dE1ldHJpYygnVjNfUE9PTF9QUk9WSURFUl9QT09MX1RSQUZGSUNfU0FNUExJTkcnLCAxLCBNZXRyaWNMb2dnZXJVbml0Lk5vbmUpXG5cbiAgICAgIGN1cnJlbnRQcm92aWRlclBvb2xzID0gYXdhaXQgdGhpcy5jdXJyZW50UG9vbFByb3ZpZGVyLmdldFBvb2xzKHRva2VuUGFpcnMsIHByb3ZpZGVyQ29uZmlnKVxuICAgICAgdGFyZ2V0UHJvdmlkZXJQb29scyA9IGF3YWl0IHRoaXMudGFyZ2V0UG9vbFByb3ZpZGVyLmdldFBvb2xzKHRva2VuUGFpcnMsIHByb3ZpZGVyQ29uZmlnKVxuICAgICAgLy8gSWYgd2UgbmVlZCB0byBzYW1wbGUgdGhlIHRyYWZmaWMsIHdlIGRvbid0IHdhbnQgdG8gbWFrZSBpdCBhIGJsb2NraW5nIEkvT1xuICAgICAgdGhpcy5zYW1wbGVUcmFmZmljKHRva2VuUGFpcnMsIGN1cnJlbnRQcm92aWRlclBvb2xzLCB0YXJnZXRQcm92aWRlclBvb2xzLCBwcm92aWRlckNvbmZpZylcbiAgICB9XG5cbiAgICBpZiAoc3dpdGNoVHJhZmZpYykge1xuICAgICAgbWV0cmljLnB1dE1ldHJpYygnVjNfUE9PTF9QUk9WSURFUl9QT09MX1RSQUZGSUNfVEFSR0VUJywgMSwgTWV0cmljTG9nZ2VyVW5pdC5Ob25lKVxuXG4gICAgICByZXR1cm4gdGFyZ2V0UHJvdmlkZXJQb29scyA/PyAoYXdhaXQgdGhpcy50YXJnZXRQb29sUHJvdmlkZXIuZ2V0UG9vbHModG9rZW5QYWlycywgcHJvdmlkZXJDb25maWcpKVxuICAgIH0gZWxzZSB7XG4gICAgICBtZXRyaWMucHV0TWV0cmljKCdWM19QT09MX1BST1ZJREVSX1BPT0xfVFJBRkZJQ19DVVJSRU5UJywgMSwgTWV0cmljTG9nZ2VyVW5pdC5Ob25lKVxuXG4gICAgICByZXR1cm4gY3VycmVudFByb3ZpZGVyUG9vbHMgPz8gKGF3YWl0IHRoaXMuY3VycmVudFBvb2xQcm92aWRlci5nZXRQb29scyh0b2tlblBhaXJzLCBwcm92aWRlckNvbmZpZykpXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBzYW1wbGVUcmFmZmljKFxuICAgIHRva2VuUGFpcnM6IFtUb2tlbiwgVG9rZW4sIEZlZUFtb3VudF1bXSxcbiAgICBjdXJyZW50UHJvdmlkZXJQb29sczogVjNQb29sQWNjZXNzb3IsXG4gICAgdGFyZ2V0UHJvdmlkZXJQb29sczogVjNQb29sQWNjZXNzb3IsXG4gICAgcHJvdmlkZXJDb25maWc/OiBQcm92aWRlckNvbmZpZ1xuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCB0cnV0aFByb3ZpZGVyUG9vbHMgPSBhd2FpdCB0aGlzLnNvdXJjZU9mVHJ1dGhQb29sUHJvdmlkZXIuZ2V0UG9vbHModG9rZW5QYWlycywgcHJvdmlkZXJDb25maWcpXG5cbiAgICB0cnV0aFByb3ZpZGVyUG9vbHMuZ2V0QWxsUG9vbHMoKS5mb3JFYWNoKChwb29sOiBQb29sKSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50UHJvdmlkZXJQb29sID0gY3VycmVudFByb3ZpZGVyUG9vbHMuZ2V0UG9vbChwb29sLnRva2VuMCwgcG9vbC50b2tlbjEsIHBvb2wuZmVlKVxuICAgICAgaWYgKCFjdXJyZW50UHJvdmlkZXJQb29sKSB7XG4gICAgICAgIC8vIFdlIGRvbid0IGV4cGVjdCBtaXNzaW5nIHBvb2wsIGJ1dCBleHBvcnQgbWV0cmljIGluIGNhc2Ugd2Ugc2VlIGFueVxuICAgICAgICBtZXRyaWMucHV0TWV0cmljKCdWM19QT09MX1BST1ZJREVSX1BPT0xfQ1VSUkVOVF9NSVNTSU5HJywgMSwgTWV0cmljTG9nZ2VyVW5pdC5Ob25lKVxuICAgICAgICBsb2cuaW5mbyhcbiAgICAgICAgICBgdjMgUG9vbCAke3Bvb2wudG9rZW4wLnN5bWJvbH0gJHtwb29sLnRva2VuMS5zeW1ib2x9ICR7cG9vbC5mZWV9IG5vdCBmb3VuZCBpbiB0aGUgY3VycmVudCBwb29sIHByb3ZpZGVyLmBcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc2FtZVF1b3RlID0gSlNCSS5lcXVhbChjdXJyZW50UHJvdmlkZXJQb29sLnNxcnRSYXRpb1g5NiwgcG9vbC5zcXJ0UmF0aW9YOTYpXG4gICAgICAgIGNvbnN0IHNhbWVMaXF1aWRpdHkgPSBKU0JJLmVxdWFsKGN1cnJlbnRQcm92aWRlclBvb2wubGlxdWlkaXR5LCBwb29sLmxpcXVpZGl0eSlcbiAgICAgICAgY29uc3QgYWNjdXJhdGUgPSBzYW1lUXVvdGUgJiYgc2FtZUxpcXVpZGl0eVxuXG4gICAgICAgIGlmICghc2FtZVF1b3RlKSB7XG4gICAgICAgICAgbG9nLmluZm8oYHYzIFBvb2wgJHtwb29sLnRva2VuMC5zeW1ib2x9ICR7cG9vbC50b2tlbjEuc3ltYm9sfSAke3Bvb2wuZmVlfSBxdW90ZSBtaXNtYXRjaDogXG4gICAgICAgICAgICBjdXJyZW50ICR7Y3VycmVudFByb3ZpZGVyUG9vbC5zcXJ0UmF0aW9YOTZ9IHZzIHRydXRoICR7cG9vbC5zcXJ0UmF0aW9YOTZ9LmApXG5cbiAgICAgICAgICBtZXRyaWMucHV0TWV0cmljKCdWM19QT09MX1BST1ZJREVSX1BPT0xfQ1VSUkVOVF9RVU9URV9NSVNNQVRDSCcsIDEsIE1ldHJpY0xvZ2dlclVuaXQuTm9uZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2FtZUxpcXVpZGl0eSkge1xuICAgICAgICAgIGxvZy5pbmZvKGB2MyBQb29sICR7cG9vbC50b2tlbjAuc3ltYm9sfSAke3Bvb2wudG9rZW4xLnN5bWJvbH0gJHtwb29sLmZlZX0gbGlxdWlkaXR5IG1pc21hdGNoOiBcbiAgICAgICAgICAgIGN1cnJlbnQgJHtjdXJyZW50UHJvdmlkZXJQb29sLmxpcXVpZGl0eX0gdnMgdHJ1dGggJHtwb29sLmxpcXVpZGl0eX0uYClcblxuICAgICAgICAgIG1ldHJpYy5wdXRNZXRyaWMoJ1YzX1BPT0xfUFJPVklERVJfUE9PTF9DVVJSRU5UX0xJUVVJRElUWV9NSVNNQVRDSCcsIDEsIE1ldHJpY0xvZ2dlclVuaXQuTm9uZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghYWNjdXJhdGUpIHtcbiAgICAgICAgICBtZXRyaWMucHV0TWV0cmljKCdWM19QT09MX1BST1ZJREVSX1BPT0xfQ1VSUkVOVF9BQ0NVUkFDWV9NSVNNQVRDSCcsIDEsIE1ldHJpY0xvZ2dlclVuaXQuTm9uZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtZXRyaWMucHV0TWV0cmljKCdWM19QT09MX1BST1ZJREVSX1BPT0xfQ1VSUkVOVF9BQ0NVUkFDWV9NQVRDSCcsIDEsIE1ldHJpY0xvZ2dlclVuaXQuTm9uZSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB0YXJnZXRQcm92aWRlclBvb2wgPSB0YXJnZXRQcm92aWRlclBvb2xzLmdldFBvb2wocG9vbC50b2tlbjAsIHBvb2wudG9rZW4xLCBwb29sLmZlZSlcbiAgICAgIGlmICghdGFyZ2V0UHJvdmlkZXJQb29sKSB7XG4gICAgICAgIC8vIFdlIGRvbid0IGV4cGVjdCBtaXNzaW5nIHBvb2wsIGJ1dCBleHBvcnQgbWV0cmljIGluIGNhc2Ugd2Ugc2VlIGFueVxuICAgICAgICBtZXRyaWMucHV0TWV0cmljKCdWM19QT09MX1BST1ZJREVSX1BPT0xfVEFSR0VUX01JU1NJTkcnLCAxLCBNZXRyaWNMb2dnZXJVbml0Lk5vbmUpXG4gICAgICAgIGxvZy5pbmZvKFxuICAgICAgICAgIGB2MyBQb29sICR7cG9vbC50b2tlbjAuc3ltYm9sfSAke3Bvb2wudG9rZW4xLnN5bWJvbH0gJHtwb29sLmZlZX0gbm90IGZvdW5kIGluIHRoZSB0YXJnZXQgcG9vbCBwcm92aWRlci5gXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHNhbWVRdW90ZSA9IEpTQkkuZXF1YWwodGFyZ2V0UHJvdmlkZXJQb29sLnNxcnRSYXRpb1g5NiwgcG9vbC5zcXJ0UmF0aW9YOTYpXG4gICAgICAgIGNvbnN0IHNhbWVMaXF1aWRpdHkgPSBKU0JJLmVxdWFsKHRhcmdldFByb3ZpZGVyUG9vbC5saXF1aWRpdHksIHBvb2wubGlxdWlkaXR5KVxuICAgICAgICBjb25zdCBhY2N1cmF0ZSA9IHNhbWVRdW90ZSAmJiBzYW1lTGlxdWlkaXR5XG5cbiAgICAgICAgaWYgKCFzYW1lUXVvdGUpIHtcbiAgICAgICAgICBsb2cuaW5mbyhgdjMgUG9vbCAke3Bvb2wudG9rZW4wLnN5bWJvbH0gJHtwb29sLnRva2VuMS5zeW1ib2x9ICR7cG9vbC5mZWV9IHF1b3RlIG1pc21hdGNoOiBcbiAgICAgICAgICAgIHRhcmdldCAke3RhcmdldFByb3ZpZGVyUG9vbC5zcXJ0UmF0aW9YOTZ9IHZzIHRydXRoICR7cG9vbC5zcXJ0UmF0aW9YOTZ9LmApXG5cbiAgICAgICAgICBtZXRyaWMucHV0TWV0cmljKCdWM19QT09MX1BST1ZJREVSX1BPT0xfVEFSR0VUX1FVT1RFX01JU01BVENIJywgMSwgTWV0cmljTG9nZ2VyVW5pdC5Ob25lKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzYW1lTGlxdWlkaXR5KSB7XG4gICAgICAgICAgbG9nLmluZm8oYHYzIFBvb2wgJHtwb29sLnRva2VuMC5zeW1ib2x9ICR7cG9vbC50b2tlbjEuc3ltYm9sfSAke3Bvb2wuZmVlfSBsaXF1aWRpdHkgbWlzbWF0Y2g6IFxuICAgICAgICAgICAgdGFyZ2V0ICR7dGFyZ2V0UHJvdmlkZXJQb29sLmxpcXVpZGl0eX0gdnMgdHJ1dGggJHtwb29sLmxpcXVpZGl0eX0uYClcblxuICAgICAgICAgIG1ldHJpYy5wdXRNZXRyaWMoJ1YzX1BPT0xfUFJPVklERVJfUE9PTF9UQVJHRVRfTElRVUlESVRZX01JU01BVENIJywgMSwgTWV0cmljTG9nZ2VyVW5pdC5Ob25lKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFhY2N1cmF0ZSkge1xuICAgICAgICAgIG1ldHJpYy5wdXRNZXRyaWMoJ1YzX1BPT0xfUFJPVklERVJfUE9PTF9UQVJHRVRfQUNDVVJBQ1lfTUlTTUFUQ0gnLCAxLCBNZXRyaWNMb2dnZXJVbml0Lk5vbmUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWV0cmljLnB1dE1ldHJpYygnVjNfUE9PTF9QUk9WSURFUl9QT09MX1RBUkdFVF9BQ0NVUkFDWV9NQVRDSCcsIDEsIE1ldHJpY0xvZ2dlclVuaXQuTm9uZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBwcml2YXRlIGdldFJhbmRvbVBlcmNlbnRhZ2UoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwKVxuICB9XG59XG4iXX0=